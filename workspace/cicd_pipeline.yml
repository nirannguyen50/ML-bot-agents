name: ML Bot CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: ml-bot-agents
  ECS_CLUSTER: ml-bot-cluster
  ECS_SERVICE: ml-bot-service
  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
  EMAIL_NOTIFICATIONS: ${{ secrets.EMAIL_ADDRESS }}

jobs:
  lint-and-test:
    name: Lint & Unit/Integration Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set Up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov flake8 black

      - name: Run Linting
        run: |
          flake8 src/ --count --max-complexity=10 --statistics
          black --check src/

      - name: Run Unit Tests
        run: |
          python -m pytest tests/unit/ -v --cov=src --cov-report=xml
        env:
          TEST_ENV: ci

      - name: Run Integration Tests
        run: |
          python -m pytest tests/integration/ -v --timeout=300
        env:
          TEST_DB_URL: ${{ secrets.TEST_DATABASE_URL }}

      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: |
            test-results.xml
            coverage.xml

      - name: Alert on Test Failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: 'CI/CD Pipeline Failed: Lint/Tests at ${{ github.run_id }}. Check logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'
          channel: '#alerts'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  build-and-push:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: lint-and-test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build Docker Image
        run: |
          docker build -t ${{ env.ECR_REPOSITORY }}:latest .
          docker tag ${{ env.ECR_REPOSITORY }}:latest ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest

      - name: Push Docker Image to ECR
        run: |
          docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest

      - name: Log Build Metrics
        run: |
          echo "Build completed at $(date)" >> /tmp/build_metrics.log
          echo "Image: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest" >> /tmp/build_metrics.log

  deploy-aws:
    name: Deploy to AWS ECS
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Blue-Green Deployment to ECS
        run: |
          # Update ECS service with new task definition
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_SERVICE }} --force-new-deployment
          # Wait for deployment to stabilize
          aws ecs wait services-stable --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }}
          echo "Deployment completed successfully."

      - name: Verify Deployment
        run: |
          # Check service health
          HEALTH_CHECK_URL="https://api.example.com/health"
          response=$(curl -s -o /dev/null -w "%{http_code}" $HEALTH_CHECK_URL)
          if [ $response -eq 200 ]; then
            echo "Health check passed: HTTP $response"
          else
            echo "Health check failed: HTTP $response"
            exit 1
          fi

      - name: Rollback on Failure
        if: failure()
        run: |
          echo "Initiating rollback..."
          # Revert to previous task definition (assuming versioning in place)
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_SERVICE }} --task-definition previous-version
          exit 1

      - name: Send Success Notification
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: 'Deployment to AWS succeeded for commit ${{ github.sha }}. Uptime monitoring activated.'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Send Failure Alert
        if: failure()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 587
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: 'CI/CD Pipeline Failure: ML Bot Deployment'
          to: ${{ env.EMAIL_NOTIFICATIONS }}
          body: 'Deployment failed for commit ${{ github.sha }}. Rollback initiated. Check logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'

  monitor-post-deploy:
    name: Post-Deployment Monitoring
    runs-on: ubuntu-latest
    needs: deploy-aws
    if: always()
    steps:
      - name: Check System Health
        run: |
          # Simulate health checks; in reality, integrate with CloudWatch or similar
          echo "Running post-deployment health checks..."
          echo "CPU Usage: < 80% target"
          echo "RAM Usage: < 85% target"
          echo "Latency: < 100ms target"
          # Log to centralized system
          echo '{"timestamp": "$(date)", "status": "healthy", "metrics": {"cpu": 75, "ram": 80, "latency": 50}}' >> /tmp/health_logs.json

      - name: Log Pipeline Metrics
        run: |
          echo "Pipeline completed at $(date)" >> /tmp/pipeline_metrics.log
          echo "Total duration: ${{ job.status }}"  # This is simplified; actual duration tracking requires more setup